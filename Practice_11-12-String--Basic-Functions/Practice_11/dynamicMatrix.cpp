//условие : заделяме ДИНАМИЧНО двумерна матрица n на m ,
//попълваме клетките със случайни числа и след това ги отпечатваме на екрана

#include<iostream> // вход - изход
#include<iomanip> //манипулация на изхода
#include<random> // за случайните числа
#include<time.h>

//генерираните числа ще са по малки от това число
const int MAXNUM = 100;
//брой клетки , в които принтим всеки елемент на матрицата
const int NCELLS = 3;

//декларираме тази функция тук горе,
//за да виждаме дефиницията й в init
void clean(int**&, size_t);


//matrix е от тип указател към масив от указатели и 
//го взимаме по референция , защото ще го пренасочваме , 
// ако не го вземем по псевдоним , ще пренасочим само копието , което ще бъде използвано от функцията
//функцията връща истина ако заделянето и попълването е успешно
bool init(int**& matrix, size_t n, size_t m){

	matrix = new (std::nothrow) int* [n];
	//ако заделянето на указателите пропадне,
	//matrix е nullptr, съответно няма какво да почистваме приключваме 
	//функцията с върнат резултар за неуспех
	if(!matrix)
		return false;

	for (size_t i = 0; i < n; i++){
		
		//опитваме да заделим памет за текущия ред
		matrix[i] = new (std::nothrow) int[m];

		//ако текущото заделяне не успее се връщаме да почистим всички 
		//успешно заделени редове
		if(!matrix[i]){

			clean(matrix,i-1);
			return false;
		}

	}

	//ако стигнем дотук, то всички алокации са били успешни,
	//можем да продължим като 
	//попълним клетките
	for (size_t i = 0; i < n; i++)
		for (size_t j = 0; j < m; j++)
			matrix[i][j] = rand() % MAXNUM;

}

//принтим числата , тук не е необходимо подаването по референция,
//защото няма да пренасочваме самият указател, a
//само ще четем от клетките, които той сочи
void print(int** matrix, size_t n, size_t m){

	for (size_t i = 0; i < n; i++){

		for (size_t j = 0; j < m; j++)
			std::cout << std::setw(NCELLS) << matrix[i][j]; 
			//всяка стойност се принти в кутийка с големина 3 символа

		std::cout << std::endl;
	}


}

//освобождаваме заделената памет
void clean(int**& matrix, size_t n){

	//освобождаваме първо редовете
	for (size_t i = 0; i < n; i++)
		delete[] matrix[i];

	//накрая масива от указателите
	delete[] matrix;

	//ако нямахме този ред можем да си спестим подаването на референция
	//но все пак искаме да се знае, че указателят матрикс е във валидно
	//състояние, просто не сочи към никаква заделена памет
	matrix = nullptr;

}

int main(){

	size_t n, m;

	//указател към място в паметта където има други указатели
	int** matrix = nullptr;

	std::cin >> n >> m;

	srand(time(NULL));

	init(matrix, n, m);

	print(matrix, n, m);

	clean(matrix, n);

	return 0;

}
